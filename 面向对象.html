<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
        // es5声明类的方式
        // function Animal(name){
        //     this.name = name
        // }
        // Animal.prototype.say = function(){
        //     console.log(this.name)
        // }
        // // es6的声明方式
        // class Animal2{
        //     constructor(name){
        //         this.name=name
        //     }
        // }

        // // 实例化一个类
        // var animal1 = new Animal('Cat')
        // var animal2 = new Animal2('Pig')
        // //console.log(animal1,animal2)


        // // 继承方式
        // // 构造函数继承
        // function Animal3(name){
        //     this.name = name;
        //     Animal.call(this,name)
        // }
        // var animal3 = new Animal3('Dog')
        // // console.log(animal3)
        // // console.log(animal3.say())// 报错
        // // 缺点  只能继承构造函数本身现有的属性和方法，原型上的属性和方法无法继承

        // //原型继承
        // function Parent1(name){
        //     this.name = name
        //     this.type="parent"
        //     this.list = [1,2,3]
        // }
        // Parent1.prototype.say = function(){
        //     console.log(this.name);
        // }
        // function Child1(name){
        //     this.name = name;
        // }
        // Child1.prototype = new Parent1('parent');
        // var child1 = new Child1('child');
        // var child2 = new Child1('child2')
        // // console.log(child1.parent);
        // // child1.say()
        // child1.list.push(4)
        // // console.log(child1.list)
        // // console.log(child2.list)


        // // 确定  如果一个子类改变了父类的属性，另一个子类也会跟着改变 ，造成这样的原因是因为他们公用了一个对象
        // // 组合继承
        // function Parent3(name){
        //     this.name = name
        //     this.list = [1,2,3]
        // }
        // Parent3.prototype.say = function(){
        //     console.log(this.name)
        // }
        // function Child3 (name){
        //     this.name = name
        //     Parent3.call(this,name)
        // }
        // Child3.prototype = new Parent3('parent')
        
        // var child3 = new Child3('child3')
        // var child4 = new Child3('child4')
        // child3.list.push(4)
        // console.log(child3.list)
        // console.log(child4.list)
        // child3.say()
        // child4.say()

        function Parent4(name){
            this.name = name
            this.list = [1,2,3]
        }
        Parent4.prototype.say = function(){
            console.log(this.name)
        }
        function Child6 (name){
            this.name = name
            Parent4.call(this,name)
        }

       
        function extend(child, parent){
            function F(){};
            F.prototype = parent.prototype
            child.prototype = new F();
            child.prototype.constructor = child;
            child.obj = parent.prototype
            if(parent.prototype.constructor === Object.prototype.constructor){
                parent.prototype.constructor = parent
            }
        }
        extend(Child6,Parent4)
        var parent4 = new Parent4('parent')
        var child6 = new Child6('chlid6')
        var child7 = new Child6('chlid7')
        child6.say()
        child7.say()
        child6.list.push(4)
        console.log(child6.list)
        console.log(child7.list)
    </script>
</body>
</html>